#include "Grid.h"

using namespace std;

//Silly round function so that I can control exactly how it works

int Grid::round_own(double a) {
	return int(a + 0.5);
}

Grid::Grid() :
			Grid::Grid(50, 50) {
}

Grid::Grid(unsigned int x, unsigned int y) {
	unsigned int ix = x + 1;
	unsigned int iy = y + 1;
	vector<Value> dummy_vec_val;
	Value dummy_val;
	dummy_val.value = 0;
	dummy_val.boundary = false;
	dummy_val.accessible = true;
	dummy_val.flag = 0;
	while (iy > 0) {
		dummy_vec_val.push_back(dummy_val);
		iy--;
	}
	while (ix > 0) {
		values.push_back(dummy_vec_val);
		ix--;
	}
	Coordinate coordinate;
	vector<Coordinate> dummy_vec_coord;
	while (ix <= x) {
		for (int z = 0; z <= y; z++) {
			coordinate.set_x((double) ix);
			coordinate.set_y(z);
			dummy_vec_coord.push_back(coordinate);
		}
		points.push_back(dummy_vec_coord);
		dummy_vec_coord.clear();
		ix++;
	}
	Grad dummy_grad;
	vector<Grad> dummy_vec_grad;
	dummy_grad.dx = 0;
	dummy_grad.dy = 0;
	ix = x + 1;
	iy = y + 1;
	while (iy > 0) {
		dummy_vec_grad.push_back(dummy_grad);
		iy--;
	}
	while (ix > 0) {
		gradients.push_back(dummy_vec_grad);
		ix--;
	}
}

Grid::~Grid() {
}


void Grid::recalculate_matrices(int x,int y) {
	Coordinate coordinate;
	vector<Coordinate> dummy_vec_coord;
	unsigned int ix = x + 1;
	unsigned int iy = y + 1;

	while (ix <= x) {
		for (int z = 0; z <= y; z++) {
			coordinate.set_x((double) ix);
			coordinate.set_y(z);
			dummy_vec_coord.push_back(coordinate);
		}
		points.push_back(dummy_vec_coord);
		dummy_vec_coord.clear();
		ix++;
	}
	Grad dummy_grad;
	vector<Grad> dummy_vec_grad;
	dummy_grad.dx = 0;
	dummy_grad.dy = 0;
	ix = x + 1;
	iy = y + 1;
	while (iy > 0) {
		dummy_vec_grad.push_back(dummy_grad);
		iy--;
	}
	while (ix > 0) {
		gradients.push_back(dummy_vec_grad);
		ix--;
	}
}

//Set range (so that it's possible to use a different increment than 1). Not really used at the moment
void Grid::set_range(double x, double y) {
	unsigned int x_size = points.size() - 1;
	unsigned int y_size = points[0].size() - 1;
	double x_mult = x / x_size;
	double y_mult = y / y_size;
	for (int it1 = 0; it1 < x_size + 1; it1++) {
		for (int it2 = 0; it2 < y_size + 1; it2++) {
			double x_val = points[it1][it2].get_x();
			double y_val = points[it1][it2].get_y();
			if (x_val != 0)
				points[it1][it2].set_x(x_val * x_mult);
			if (y_val != 0)
				points[it1][it2].set_y(y_val * y_mult);
		}
	}
}

//Set value of individual cell without making it a boundary point

void Grid::set_value(unsigned int x, unsigned int y, double val) {
	assert(x < values.size() && y < values[0].size() && "Outside of range");
	values[x][y].value = val;
}

//Make a cell a boundary point without changing its value

void Grid::set_boundary_point(unsigned int x, unsigned int y, bool bound) {
	assert(x < values.size() && y < values[0].size() && "Outside of range");
	values[x][y].boundary = bound;
}

//Set both value and make boundary point (most commonly used I imagine)

void Grid::set_boundary_value(unsigned int x, unsigned int y, double val) {
	assert(x < values.size() && y < values[0].size() && "Outside of range");
	values[x][y].boundary = true;
	values[x][y].value = val;
}

//Same as above but accepts doubles (so if you for some reason want to define
//a boundary shape in your own code you won't have to round floats all the time)

void Grid::set_boundary_value_float(double xd, double yd, double val) {
	unsigned int x = round_own(abs(xd));
	unsigned int y = round_own(abs(yd));
	assert(x < values.size() && y < values[0].size() && "Outside of range");
	values[x][y].boundary = true;
	values[x][y].value = val;
}

void Grid::set_flow(double left, double right) {
	double gradient = (right - left) / (values.size() - 1);
	for (int y = 0; y < values[0].size(); y++) {
		values[0][y].value = left;
		values[0][y].boundary = true;
		values[values.size() - 1][y].value = right;
		values[values.size() - 1][y].boundary = true;
	}
	for (int x = 0; x < values.size(); x++) {
		values[x][0].value = left + x * gradient;
		values[x][0].boundary = true;
		values[x][values[0].size() - 1].value = left + x * gradient;
		values[x][values[0].size() - 1].boundary = true;
	}
	for (int y = 1; y < values[0].size() - 1; y++) {
		for (int x = 1; x < values.size() - 1; x++) {
			values[x][y].value = left + x * gradient;
		}
	}
}

coordinate_matrix Grid::get_coordinates() {
	return points;
}
matrix Grid::get_values() {
	return values;
}
grad_matrix Grid::get_gradients() {
	return gradients;
}

double Grid::get_value(unsigned x, unsigned y) {
	return values[x][y].value;
} 

int Grid::get_xmax() {
	return values.size();
}

int Grid::get_ymax() {
	return values[0].size();
}
void Grid::set_coordinates(coordinate_matrix coords) {
	points = coords;
}
void Grid::set_values(matrix vals) {
	values = vals;
}
void Grid::set_gradients(grad_matrix grads) {
	gradients = grads;
}

//finds -ve gradient of each point in x and y direction. Equivalent to E_x and E_y. assumes increment =1.
void Grid::efield() {
	double dx1, dy1;
	for (int x = 0; x < values.size(); x++) {
		for (int y = 0; y < values[0].size(); y++) {
			if ( x== values.size()-1 ) {gradients[x][y].e_size = gradients[x-1][y].e_size;}
			else if ( y== values[0].size()-1 ) {gradients[x][y].e_size = gradients[x][y-1].e_size;}
			else {
			dx1 = values[x][y].value - values[x + 1][y].value;
			dy1 = values[x][y].value - values[x][y + 1].value;
			gradients[x][y].e_size = (x-25)*(sqrt(2.0)*sqrt(dx1*dx1+dy1*dy1));
			}
			
		}
	}

for (int x = 0; x < values.size(); x++) {
		for (int y = 0; y < values[0].size(); y++) {
			values[x][y].value = gradients[x][y].e_size;
		}
	}
}

 

// small function that compares two Value type variables (.value and .flag). returns 1 if they are equal

bool Grid::compare(Value nn, Value mm) {
	if (nn.value == mm.value && nn.flag == mm.flag) {
		return 1;
	} else
		return 0;
}

// calculates equip.lines. n - number of eq.lines you need. xmax, ymax, Emax - obvious. line_width: for ex, if line-width
// is set to 2, it means it will have width of 2 points. ( if line_width = 1 and grid is 50x50, the lines will be very wide,
// on the contrary, if line_width = 1 and grid 500x500 , they will be 10 times narrower). menu:
// 1 - a point is equal to 2 if it is on equipotential, equal to 1 if it is on the object
// 2 - prints out only eq.lines with values of 1
// 3 - plots eq.lines with different values, and an object of 2*Emax value
// 4 - plots only eq.lines with different values

void Grid::equip_values(int n, int xmax, int ymax, double Emax)
{
	set_flags_to_zero();
	double yx = (double) ymax / (n - 1);
	int flag_numb = 1;

	for (double ii = 1; ii <= ymax-1; ii = ii + yx)
	{
		int i = round_own(ii);
		int yi = i;
		int xi = 0;
		Value prev_prev;
		prev_prev.value = 0;
		prev_prev.flag = flag_numb;
		Value prev;
		prev.value = 0;
		prev.flag = flag_numb;
		Value current = values[xi][yi];
		values[xi][yi].flag=flag_numb;
		for (;;)
		{
			if (values[xi+1][yi].value >= values[xi][yi-1].value && values[xi+1][yi].value >= values[xi][yi+1].value ) {
				check_and_mark_cells(xi, yi, 1, 0, prev_prev, prev, current, flag_numb);
			}
			else if (values[xi][yi-1].value >= values[xi][yi+1].value ) {
				 check_and_mark_cells(xi, yi, 0, -1, prev_prev, prev, current, flag_numb);
			}
			else {check_and_mark_cells(xi, yi, 0, 1, prev_prev, prev, current, flag_numb);}
			if ( xi<= 0 || xi >= xmax || yi <= 0 || yi >= ymax)
			{
				break;
			}
			else if (values[xi][yi].boundary ==1) 
			{	
				int i = round_own(ii);
				int yi = i;
				int xi = xmax-1;
				Value prev_prev;
				prev_prev.value = 0;
				prev_prev.flag = flag_numb;
				Value prev;
				prev.value = 0;
				prev.flag = flag_numb;
				Value current = values[xi][yi];
				values[xi][yi].flag=flag_numb;
				for (;;)
				{
					cout << "1" << endl;
					if (values[xi-1][yi].value <= values[xi][yi-1].value && values[xi-1][yi].value <= values[xi][yi+1].value ) {
						check_and_mark_cells(xi, yi, -1, 0, prev_prev, prev, current, flag_numb);cout << "2" << endl;
					}
					else if (values[xi][yi-1].value <= values[xi][yi+1].value ) {
						 check_and_mark_cells(xi, yi, 0, -1, prev_prev, prev, current, flag_numb);cout << "3" << endl;
					}
					else {check_and_mark_cells(xi, yi, 0, 1, prev_prev, prev, current, flag_numb);cout << "4" << endl;}
					if ( xi<= 0 || xi >= xmax || yi <= 0 || yi >= ymax || values[xi][yi].boundary == 1)
					{
						break;
					}
				}
				break;
			}
		}
		++flag_numb;
	}
	for (int xs = 0; xs < values.size(); xs++) {
		for (int ys = 0; ys < values[0].size(); ys++) {
			if (values[xs][ys].boundary == 1) {
				values[xs][ys].value = 1;
			} else if ((values[xs][ys].flag != 0)) {
				values[xs][ys].value = 2;
			} else {
				values[xs][ys].value = 0;
			}
			if ((xs == 0 || ys == 0 || xs == values.size() - 1
					|| ys == values[0].size() - 1)
					&& (values[xs][ys].flag == 0)) {
				values[xs][ys].value = 0;
			} else if ((xs == 0 || ys == 0 || xs == values.size() - 1
					|| ys == values[0].size() - 1)
					&& (values[xs][ys].flag !=0)) {
				values[xs][ys].value = 2;
			}
		}
	}
}
				



/*void Grid::equip_values(int n, int xmax, int ymax, double Emax, int line_width,
		int menu) {

	set_flags_to_zero();
	double yx = (double) ymax / (n - 1);
	int flag_numb = 1;

	for (double ii = 0; ii <= 40; ii = ii + yx)
	{
		int i = round_own(ii);
		int yi = i;
		int xi = 0;
		Value prev_prev;
		prev_prev.value = 999.999;
		prev_prev.flag = flag_numb;
		Value prev;
		prev.value = 999.998;
		prev.flag = flag_numb;
		Value current = values[xi][yi];
		double eq_val = values[xi][yi].value;
		double diff_left = 100;
		if (yi != ymax)
		{
			diff_left = abs(values[xi][yi+1].value - eq_val);
		}
		double diff_right = 100;
		if (yi != 0)
		{
			diff_right = abs(values[xi][yi-1].value - eq_val);
		}
		double diff_up = abs(values[xi+1][yi].value - eq_val);
		values[xi][yi].flag = flag_numb;

		if (diff_up <= diff_right && diff_up <= diff_left) 
		{
			check_and_mark_cells(xi, yi, 1, 0, prev_prev, prev, current, flag_numb);

		} 
		else if (diff_right < diff_left) 
		{
			check_and_mark_cells(xi, yi, 0, -1, prev_prev, prev, current, flag_numb);
		} 
		else if (diff_right == diff_left) 
		{
			if (abs(values[xi+1][yi+1].value - eq_val) > abs(values[xi+1][yi-1].value - eq_val)) 
			{
				check_and_mark_cells(xi, yi, 0, 1, prev_prev, prev, current, flag_numb);
			}
			else 
			{
			check_and_mark_cells(xi, yi, 0, -1, prev_prev, prev,current, flag_numb);
			}
		}

		else 
		{
			check_and_mark_cells(xi, yi, 0, 1, prev_prev, prev, current, flag_numb);
		}

		for (;;) 
		{
			if (yi == 0
					|| (compare(prev, values[xi][yi-1])
							|| (compare(prev, values[xi-1][yi])
									&& compare(prev_prev,
											values[xi - 1][yi - 1])))) 
			{
				diff_left = abs(values[xi][yi+1].value - eq_val);
				diff_up = abs(values[xi+1][yi].value - eq_val);
				if (diff_up <= diff_left) 
				{
					check_and_mark_cells(xi, yi, 1, 0, prev_prev, prev,
							current, flag_numb);
				} 
				else 
				{
					check_and_mark_cells(xi, yi, 0, 1, prev_prev, prev,
							current, flag_numb);
				}
			}

			else if (yi == ymax
					|| (compare(prev, values[xi][yi+1])
							|| (compare(prev, values[xi-1][yi])
									&& compare(prev_prev,
											values[xi - 1][yi + 1])))) 
			{
				diff_right = abs(values[xi][yi-1].value - eq_val);
				diff_up = abs(values[xi+1][yi].value - eq_val);
				if (diff_up <= diff_right) 
				{
					check_and_mark_cells(xi, yi, 1, 0, prev_prev, prev,
							current, flag_numb);
				} 
				else 
				{
					check_and_mark_cells(xi, yi, 0, -1, prev_prev, prev,
							current, flag_numb);
				}
			} 
			else 
			{
				diff_left = abs(values[xi][yi+1].value - eq_val);
				diff_right = abs(values[xi][yi-1].value - eq_val);
				diff_up = abs(values[xi+1][yi].value - eq_val);

				if ((diff_up <= diff_right) && (diff_up <= diff_left)) 
				{
					check_and_mark_cells(xi, yi, 1, 0, prev_prev, prev,
							current, flag_numb);
				} 
				else if (diff_right < diff_left) 
				{
					check_and_mark_cells(xi, yi, 0, -1, prev_prev, prev,
							current, flag_numb);
				} 
				else if (diff_right == diff_left) 
				{
					if (abs(values[xi+1][yi+1].value - eq_val) > abs(values[xi+1][yi-1].value - eq_val)) 
					{
						check_and_mark_cells(xi, yi, 0, 1, prev_prev, prev, current, flag_numb);
					} 
					else 
					{
						check_and_mark_cells(xi, yi, 0, -1, prev_prev, prev,current, flag_numb);
					}

				} 
				else 
				{
					check_and_mark_cells(xi, yi, 0, 1, prev_prev, prev,
							current, flag_numb);
				}
			}
			cout << xi << "\t" << yi << "\t" << values[xi][yi].boundary << endl;
			if (xi >= xmax || yi < 0 || yi > ymax) 
			{
				break; 
			}
			else if (xi >= 2 &&  xi <= xmax -2 && yi <= ymax -2 && yi >= 2
					&& ( values[xi-1][yi].boundary == 1 || values[xi][yi+1].boundary == 1 || values[xi][yi-1].boundary == 1 ))
			{
				break; 
			}
		}

// extra code for case if the eq. line goes through the figure

		if (xi >= 2 &&  xi <= xmax -2 && yi <= ymax -2 && yi >= 2
					&& ( values[xi-1][yi].boundary == 1 || values[xi][yi+1].boundary == 1 || values[xi][yi-1].boundary == 1 ))
		{
			int i = round_own(ii);
			int yi = i;
			int xi = xmax;
			Value prev_prev;
			prev_prev.value = 999.999;
			prev_prev.flag = flag_numb;
			Value prev;
			prev.value = 999.998;
			prev.flag = flag_numb;
			Value current = values[xi][yi];
			double eq_val = values[xi][yi].value;
			double diff_left = 100;
			cout << xi << "\t" << yi << "\t" << values[xi][yi].boundary << endl;
			if (yi != ymax) 
				{
					diff_left = abs(values[xi][yi+1].value - eq_val);
				}
				double diff_right = 100;
				if (yi != 0) 
				{
					diff_right = abs(values[xi][yi-1].value - eq_val);
				}
				double diff_up = abs(values[xi-1][yi].value - eq_val);
				values[xi][yi].flag = flag_numb;

				if (diff_up <= diff_right && diff_up <= diff_left) 
				{
					check_and_mark_cells(xi, yi, -1, 0, prev_prev, prev, current, flag_numb);

				} 
				else if (diff_right < diff_left) 
				{
					check_and_mark_cells(xi, yi, 0, -1, prev_prev, prev, current, flag_numb);
				} 
				else if (diff_right == diff_left) 
				{
					if (abs(values[xi-1][yi+1].value - eq_val) > abs(values[xi-1][yi-1].value - eq_val)) 
					{
						check_and_mark_cells(xi, yi, 0, 1, prev_prev, prev, current, flag_numb);
					} 
					else 
					{
						check_and_mark_cells(xi, yi, 0, -1, prev_prev, prev,current, flag_numb);
					}
				}

				 else 
				{
					check_and_mark_cells(xi, yi, 0, 1, prev_prev, prev, current, flag_numb);
				}
				cout << xi << "\t" << yi << "\t" << values[xi][yi].boundary << endl;
				for (;;) 
				{
					cout << xi << "\t" << yi << "\t" << values[xi][yi].boundary << endl;
					if (yi == 0
							|| (compare(prev, values[xi][yi-1])
									|| (compare(prev, values[xi+1][yi])
											&& compare(prev_prev,
													values[xi + 1][yi - 1])))) 
					{
						diff_left = abs(values[xi][yi+1].value - eq_val);
						diff_up = abs(values[xi-1][yi].value - eq_val);
						if (diff_up <= diff_left) {
							check_and_mark_cells(xi, yi, -1, 0, prev_prev, prev,
									current, flag_numb);
						} 
						else 
						{
							check_and_mark_cells(xi, yi, 0, 1, prev_prev, prev,
									current, flag_numb);
						}
					}

					else if (yi == ymax
							|| (compare(prev, values[xi][yi+1])
									|| (compare(prev, values[xi-1][yi])
											&& compare(prev_prev,
													values[xi + 1][yi + 1])))) 
					{
						diff_right = abs(values[xi][yi-1].value - eq_val);
						diff_up = abs(values[xi-1][yi].value - eq_val);
						if (diff_up <= diff_right) 
						{
							check_and_mark_cells(xi, yi, -1, 0, prev_prev, prev,
								current, flag_numb);
						} 
						else 
						{
						check_and_mark_cells(xi, yi, 0, -1, prev_prev, prev,
								current, flag_numb);
						}
					} 
					else 
					{
						diff_left = abs(values[xi][yi+1].value - eq_val);
						diff_right = abs(values[xi][yi-1].value - eq_val);
						diff_up = abs(values[xi-1][yi].value - eq_val);

						if ((diff_up <= diff_right) && (diff_up <= diff_left)) 
						{
							check_and_mark_cells(xi, yi, -1, 0, prev_prev, prev,
									current, flag_numb);
						} 
						else if (diff_right < diff_left) 
						{
							check_and_mark_cells(xi, yi, 0, -1, prev_prev, prev,
									current, flag_numb);
						} 
						else if (diff_right == diff_left) 
						{
							if (abs(values[xi-1][yi+1].value - eq_val) > abs(values[xi-1][yi-1].value - eq_val)) 
							{
								check_and_mark_cells(xi, yi, 0, 1, prev_prev, prev, current, flag_numb);
							} 
							else 
							{
								check_and_mark_cells(xi, yi, 0, -1, prev_prev, prev,current, flag_numb);
							}

						} 
						else 
						{
							check_and_mark_cells(xi, yi, 0, 1, prev_prev, prev,
									current, flag_numb);
						}
					}

					if (xi <= 0 || yi < 0 || yi > ymax) 
					{
						break;
					}
					else if (xi >= 2 &&  xi <= xmax -2 && yi <= ymax -2 && yi >= 2
					&& ( values[xi-1][yi].boundary == 1 || values[xi][yi+1].boundary == 1 || values[xi][yi-1].boundary == 1 ))
					{
						break;
					}
				}
	}
	++flag_numb;	
}


// This part of the code outputs the values for each point depending on value of "menu" set by user

	if (menu == 1) {

		for (int xs = 0; xs < values.size(); xs++) {
			for (int ys = 0; ys < values[0].size(); ys++) {
				if (values[xs][ys].boundary == 1) {
					values[xs][ys].value = 1;
				} else if ((values[xs][ys].flag != 0)) {
					values[xs][ys].value = 2;
				} else {
					values[xs][ys].value = 0;
				}
				if ((xs == 0 || ys == 0 || xs == values.size() - 1
						|| ys == values[0].size() - 1)
						&& (values[xs][ys].flag == 0)) {
					values[xs][ys].value = 0;
				} else if ((xs == 0 || ys == 0 || xs == values.size() - 1
						|| ys == values[0].size() - 1)
						&& (values[xs][ys].flag !=0)) {
					values[xs][ys].value = 2;
				}
			}
		}
	}
}
*/
// small function used equip_values(...);

void Grid::check_and_mark_cells(int &xa, int &ya, int deltax, int deltay,
		Value &prev_prev2, Value &prev2, Value &current2, int flag_numb2) {
	xa = xa + deltax;
	ya = ya + deltay;
	values[xa][ya].flag = flag_numb2;
	prev_prev2 = prev2;
	prev2 = current2;
	current2 = values[xa][ya];
}

// set all flags to zero

void Grid::set_flags_to_zero() {

	for (int xs = 0; xs < values.size(); xs++) 
		for (int ys = 0; ys < values[0].size(); ys++) 
			values[xs][ys].flag = 0; 
	}

// gets the outline of the figure; used in print_figure_to(...) 

void Grid::get_surface_points_of_figure() {
		for (int xs = 1; xs < values.size()-1; xs++) {
			for (int ys = 1; ys < values[0].size()-1; ys++) {
				if ((values[xs][ys].boundary == 1) && !( (values[xs-1][ys].boundary == 0 && values[xs][ys-1].boundary == 0 && values[xs+1][ys].boundary == 0 && values[xs][ys+1].boundary == 0 )) && !((values[xs-1][ys].boundary == 1 && values[xs][ys-1].boundary == 1 && values[xs+1][ys].boundary == 1 && values[xs][ys+1].boundary == 1 ) ) ) { values[xs][ys].flag = 10000000;}
			}
		}	
}	

//Think of this as a simple way to create a uniform electric field (or liquid flow)
//from left to right or the other way around

//Create an inaccessible circle

void Grid::set_circle_noflow(int x, int y, unsigned int r, double val) {
	if (x - r < 0 || x + r > values.size() - 1 || y - r < 0
			|| y + r > values[0].size() - 1)
		cout << "Out of range." << endl;
	else {
		for (int xs = x - r; xs <= x + r; xs++) {
			for (int ys = y - r; ys <= y + r; ys++) {
				Coordinate xy;
				xy.set_xy(xs, ys);
				Coordinate mid;
				mid.set_xy(x, y);
				if (mid.distance(xy) < r) {
					values[xs][ys].value = val;
					values[xs][ys].accessible = false;
				}
			}
		}
	}
}

void Grid::set_boundary_shape(int x1, int y1, int r, int z, double val,
		Shape shape) {
	set_boundary_shape(x1,y1,r,z,val,shape,0,0,0,0,0,0);
}

void Grid::set_boundary_shape(int x1, int y1, int r, int z, double val,
		Shape shape, int x2, int x3, int x4, int y2, int y3, int y4) {

	switch (shape) {

	///CIRCLE
	case circle: {
		if (x1 - r < 0 || x1 + r > values.size() - 1 || y1 - r < 0
				|| y1 + r > values[0].size() - 1)
			cout << "Out of range." << endl;
		else {
			for (int xs = x1 - r; xs <= x1 + r; xs++) {
				for (int ys = y1 - r; ys <= y1 + r; ys++) {
					Coordinate xy;
					xy.set_xy(xs, ys);
					Coordinate mid;
					mid.set_xy(x1, y1);
					if (mid.distance(xy) < r) {
						values[xs][ys].value = val;
						values[xs][ys].boundary = true;
					}
				}
			}
		}
		break;
	}

	//SEMICIRCLES
	case semicircle_north: {
		if (x1 - r < 0 || x1 + r > values.size() - 1 || y1 < 0
				|| y1 + r > values[0].size() - 1)
			cout << "Out of range." << endl;
		else {
			for (int xs = x1 - r; xs <= x1 + r; xs++) {
				for (int ys = y1; ys <= y1 + r; ys++) {
					Coordinate xy;
					xy.set_xy(xs, ys);
					Coordinate mid;
					mid.set_xy(x1, y1);
					if (mid.distance(xy) < r) {
						values[xs][ys].value = val;
						values[xs][ys].boundary = true;
					}
				}
			}
		}
		break;
	}

	case semicircle_south: {
		if (x1 - r < 0 || x1 + r > values.size() - 1 || y1 - r < 0
				|| y1 > values[0].size() - 1)
			cout << "Out of range." << endl;
		else {
			for (int xs = x1 - r; xs <= x1 + r; xs++) {
				for (int ys = y1 - r; ys <= y1; ys++) {
					Coordinate xy;
					xy.set_xy(xs, ys);
					Coordinate mid;
					mid.set_xy(x1, y1);
					if (mid.distance(xy) < r) {
						values[xs][ys].value = val;
						values[xs][ys].boundary = true;
					}
				}
			}
		}
		break;
	}

	case semicircle_east: {
		if (x1 < 0 || x1 + r > values.size() - 1 || y1 - r < 0
				|| y1 > values[0].size() - 1)
			cout << "Out of range." << endl;
		else {
			for (int xs = x1; xs <= x1 + r; xs++) {
				for (int ys = y1 - r; ys <= y1 + r; ys++) {
					Coordinate xy;
					xy.set_xy(xs, ys);
					Coordinate mid;
					mid.set_xy(x1, y1);
					if (mid.distance(xy) < r) {
						values[xs][ys].value = val;
						values[xs][ys].boundary = true;
					}
				}
			}
		}
		break;
	}

	case semicircle_west: {
		if (x1 - r < 0 || x1 > values.size() - 1 || y1 - r < 0
				|| y1 > values[0].size() - 1)
			cout << "Out of range." << endl;
		else {
			for (int xs = x1 - r; xs <= x1; xs++) {
				for (int ys = y1 - r; ys <= y1 + r; ys++) {
					Coordinate xy;
					xy.set_xy(xs, ys);
					Coordinate mid;
					mid.set_xy(x1, y1);
					if (mid.distance(xy) < r) {
						values[xs][ys].value = val;
						values[xs][ys].boundary = true;
					}
				}
			}
		}
		break;
	}

	///RECTANGLE
	case rectangle: {
		x2 = y1;
		y1 = r;
		y2 = z;
		if (x1 > values.size() - 1 || x2 > values.size() - 1
				|| y1 > values.size() - 1 || y2 > values.size() - 1)
			cout << "Out of range." << endl;
		else {
			for (int xs = min(x1, x2); xs <= max(x1, x2); xs++) {
				for (int ys = min(y1, y2); ys <= max(y1, y2); ys++) {
					values[xs][ys].value = val;
					values[xs][ys].boundary = true;
				}
			}
		}
		break;
	}

	///TRIANGLE
	case triangle: {
		x2 = y1;
		int y_base = r;
		int y_tip = z;
		if (x1 > values.size() - 1 || x2 > values.size() - 1
				|| y_base > values.size() - 1 || y_tip > values.size() - 1)
			cout << "Out of range." << endl;
		else {
			double slope = (double) (y_tip - y_base) / (0.5 * abs(x1 - x2));
			int xc = (x1 + x2) / 2;
			for (int xs = min(x1, x2); xs <= max(x1, x2); xs++) {
				for (int ys = min(y_tip, y_base); ys <= max(y_tip, y_base);
						ys++) {
					if (y_tip > y_base && ys <= y_tip + slope * (xs - xc)
							&& ys <= y_tip - slope * (xs - xc)) {
						values[xs][ys].value = val;
						values[xs][ys].boundary = true;
					}
					if (y_tip < y_base && ys >= y_tip + slope * (xs - xc)
							&& ys >= y_tip - slope * (xs - xc)) {
						values[xs][ys].value = val;
						values[xs][ys].boundary = true;
					}
				}
			}
		}
		break;
	}

	///ELLIPSE
	case ellipse: {
		int rx = r;
		int ry = z;
		if (x1 - rx < 0 || y1 - ry < 0 || x1 + rx > values.size() - 1
				|| y1 + ry > values.size() - 1)
			cout << "Out of range." << endl;
		for (int xs = x1 - rx; xs <= x1 + rx; xs++) {
			for (int ys = y1 - ry; ys <= y1 + ry; ys++) {
				if (pow(((double) (xs - x1) / rx), 2)
						+ pow(((double) (ys - y1) / ry), 2) <= 1) {
					values[xs][ys].value = val;
					values[xs][ys].boundary = true;
				}
			}
		}
		break;
	}

	case star: {
		if (x1 > values.size() - 1 || x4 > values.size() - 1 || y1 > values.size() - 1 || y4 > values.size() - 1)
			cout << "Out of range." << endl;
		else {
			for (int xs=x2; xs <= x3; xs++) {
				for (int ys=y2; ys <= y3; ys++) {
					values[xs][ys].value=val;
					values[xs][ys].boundary=true;
				}
			}

			double slope=(double) (y4 - y3)/ (0.5*(x3 - x2));
			double xc=(x2+x3)/2;
			for (int xs=x2; xs <= x3; xs++) {
				for (int ys=y3; ys <= y4; ys++) {
					if ( ys <= y4 + slope * (xs - xc) && ys <= y4 - slope * (xs - xc)) {
						values[xs][ys].value = val;
						values[xs][ys].boundary = true;
					}
				}
			}

			for (int xs=x2; xs <= x3; xs++) {
				for (int ys=y1; ys <= y2; ys++) {
					if ( ys >= y1 + slope * (xs - xc) && ys >= y1 - slope * (xs - xc)) {
						values[xs][ys].value = val;
						values[xs][ys].boundary = true;
					}
				}
			}

			slope=(double) (x4 - x3)/ (0.5*(y3 - y2));
			double yc=(y2+y3)/2;
			for (int ys=y2; ys <= y3; ys++) {
				for (int xs=x3; xs <= x4; xs++) {
					if ( xs <= x4 + slope * (ys - yc) && xs <= x4 - slope * (ys - yc)) {
						values[xs][ys].value = val;
						values[xs][ys].boundary = true;
					}
				}
			}

			for (int ys=y2; ys <= y3; ys++) {
				for (int xs=x1; xs <= x2; xs++) {
					if ( xs >= x1 + slope * (ys - yc) && xs >= x1 - slope * (ys - yc)) {
						values[xs][ys].value = val;
						values[xs][ys].boundary = true;
					}
				}
			}
		}
		break;
	}
	case random_shape: {
		srand(time(0));
		int rand_shape = rand() % 9;
		Shape new_shape;
		switch (rand_shape) {
		case 0:
			new_shape = circle;
			break;
		case 1:
			new_shape = semicircle_north;
			break;
		case 2:
			new_shape = semicircle_south;
			break;
		case 3:
			new_shape = semicircle_west;
			break;
		case 4:
			new_shape = semicircle_east;
			break;
		case 5:
			new_shape = rectangle;
			break;
		case 6:
			new_shape = triangle;
			break;
		case 7:
			new_shape = ellipse;
			break;
		case 8:
			new_shape = star;
			break;
		}
		int x1 = 1 + rand()%(values.size() - 3);
		int x2 = 1 + rand()%(values.size() - 3);
		int x3 = 1 + rand()%(values.size() - 3);
		int x4 = 1 + rand()%(values.size() - 3);
		int x5 = (1 + rand()%(values.size() - 3) + 1 + rand()%(values[0].size() - 3)) / 4;

		int y1 = 1 + rand()%(values[0].size() - 3);
		int y2 = 1 + rand()%(values[0].size() - 3);
		int y3 = 1 + rand()%(values[0].size() - 3);
		int y4 = 1 + rand()%(values[0].size() - 3);
		int y5 = (1 + rand()%(values.size() - 3) + 1 + rand()%(values[0].size() - 3)) / 4;

		set_boundary_shape(x1,y1,x5,y5, val, new_shape,x2,x3,x4,y2,y3,y4);
	}

	} ///end of switch
}

void Grid::set_boundary_shape(int x, int y, int r, int z,
		Shape shape) {
	set_boundary_shape(x,y,r,z,shape,0,0,0,0,0,0);
}

void Grid::set_boundary_shape(int x, int y, int r, int z,
		Shape shape,  int x2, int x3, int x4, int y2, int y3, int y4) {

	switch (shape) {

	///CIRCLE
	case circle: {
		if (x - r < 0 || x + r > values.size() - 1 || y - r < 0
				|| y + r > values[0].size() - 1)
			cout << "Out of range." << endl;
		else {
			for (int xs = x - r; xs <= x + r; xs++) {
				for (int ys = y - r; ys <= y + r; ys++) {
					Coordinate xy;
					xy.set_xy(xs, ys);
					Coordinate mid;
					mid.set_xy(x, y);
					if (mid.distance(xy) < r) {
						values[xs][ys].boundary = true;
						values[xs][ys].flag = 1;
					}
				}
			}
		}
		break;
	}

	//SEMICIRCLES
	case semicircle_north: {
		if (x - r < 0 || x + r > values.size() - 1 || y < 0
				|| y + r > values[0].size() - 1)
			cout << "Out of range." << endl;
		else {
			for (int xs = x - r; xs <= x + r; xs++) {
				for (int ys = y; ys <= y + r; ys++) {
					Coordinate xy;
					xy.set_xy(xs, ys);
					Coordinate mid;
					mid.set_xy(x, y);
					if (mid.distance(xy) < r) {
						values[xs][ys].boundary = true;
						values[xs][ys].flag = 1;
					}
				}
			}
		}
		break;
	}

	case semicircle_south: {
		if (x - r < 0 || x + r > values.size() - 1 || y - r < 0
				|| y > values[0].size() - 1)
			cout << "Out of range." << endl;
		else {
			for (int xs = x - r; xs <= x + r; xs++) {
				for (int ys = y - r; ys <= y; ys++) {
					Coordinate xy;
					xy.set_xy(xs, ys);
					Coordinate mid;
					mid.set_xy(x, y);
					if (mid.distance(xy) < r) {
						values[xs][ys].boundary = true;
						values[xs][ys].flag = 1;
					}
				}
			}
		}
		break;
	}

	case semicircle_east: {
		if (x < 0 || x + r > values.size() - 1 || y - r < 0
				|| y > values[0].size() - 1)
			cout << "Out of range." << endl;
		else {
			for (int xs = x; xs <= x + r; xs++) {
				for (int ys = y - r; ys <= y + r; ys++) {
					Coordinate xy;
					xy.set_xy(xs, ys);
					Coordinate mid;
					mid.set_xy(x, y);
					if (mid.distance(xy) < r) {
						values[xs][ys].boundary = true;
						values[xs][ys].flag = 1;
					}
				}
			}
		}
		break;
	}

	case semicircle_west: {
		if (x - r < 0 || x > values.size() - 1 || y - r < 0
				|| y > values[0].size() - 1)
			cout << "Out of range." << endl;
		else {
			for (int xs = x - r; xs <= x; xs++) {
				for (int ys = y - r; ys <= y + r; ys++) {
					Coordinate xy;
					xy.set_xy(xs, ys);
					Coordinate mid;
					mid.set_xy(x, y);
					if (mid.distance(xy) < r) {
						values[xs][ys].boundary = true;
						values[xs][ys].flag = 1;
					}
				}
			}
		}
		break;
	}

	///RECTANGLE
	case rectangle: {
		int x1 = x;
		int x2 = y;
		int y1 = r;
		int y2 = z;
		if (x1 > values.size() - 1 || x2 > values.size() - 1
				|| y1 > values.size() - 1 || y2 > values.size() - 1)
			cout << "Out of range." << endl;
		else {
			for (int xs = min(x1, x2); xs <= max(x1, x2); xs++) {
				for (int ys = min(y1, y2); ys <= max(y1, y2); ys++) {
					values[xs][ys].boundary = true;
					values[xs][ys].flag = 1;
				}
			}
		}
		break;
	}

	///TRIANGLE
	case triangle: {
		int x1 = x;
		int x2 = y;
		int y_base = r;
		int y_tip = z;
		if (x1 > values.size() - 1 || x2 > values.size() - 1
				|| y_base > values.size() - 1 || y_tip > values.size() - 1)
			cout << "Out of range." << endl;
		else {
			double slope = (double) (y_tip - y_base) / (0.5 * abs(x1 - x2));
			int xc = (x1 + x2) / 2;
			for (int xs = min(x1, x2); xs <= max(x1, x2); xs++) {
				for (int ys = min(y_tip, y_base); ys <= max(y_tip, y_base);
						ys++) {
					if (y_tip > y_base && ys <= y_tip + slope * (xs - xc)
							&& ys <= y_tip - slope * (xs - xc)) {
						values[xs][ys].boundary = true;
						values[xs][ys].flag = 1;
					}
					if (y_tip < y_base && ys >= y_tip + slope * (xs - xc)
							&& ys >= y_tip - slope * (xs - xc)) {
						values[xs][ys].boundary = true;
						values[xs][ys].flag = 1;
					}
				}
			}
		}
		break;
	}

	///ELLIPSE
	case ellipse: {
		int rx = r;
		int ry = z;
		if (x - rx < 0 || y - ry < 0 || x + rx > values.size() - 1
				|| y + ry > values.size() - 1)
			cout << "Out of range." << endl;
		for (int xs = x - rx; xs <= x + rx; xs++) {
			for (int ys = y - ry; ys <= y + ry; ys++) {
				if (pow(((double) (xs - x) / rx), 2)
						+ pow(((double) (ys - y) / ry), 2) <= 1) {
					values[xs][ys].boundary = true;
					values[xs][ys].flag = 1;
				}
			}
		}
		break;
	}
	case star: {
		int x1 = x;
		int y1 = y;
		if (x1 > values.size() - 1 || x4 > values.size() - 1 || y1 > values.size() - 1 || y4 > values.size() - 1)
			cout << "Out of range." << endl;
		else {
			for (int xs=x2; xs <= x3; xs++) {
				for (int ys=y2; ys <= y3; ys++) {
					values[xs][ys].flag=1;
					values[xs][ys].boundary=true;
				}
			}

			double slope=(double) (y4 - y3)/ (0.5*(x3 - x2));
			double xc=(x2+x3)/2;
			for (int xs=x2; xs <= x3; xs++) {
				for (int ys=y3; ys <= y4; ys++) {
					if ( ys <= y4 + slope * (xs - xc) && ys <= y4 - slope * (xs - xc)) {
						values[xs][ys].flag=1;
						values[xs][ys].boundary = true;
					}
				}
			}

			for (int xs=x2; xs <= x3; xs++) {
				for (int ys=y1; ys <= y2; ys++) {
					if ( ys >= y1 + slope * (xs - xc) && ys >= y1 - slope * (xs - xc)) {
						values[xs][ys].flag=1;
						values[xs][ys].boundary = true;
					}
				}
			}

			slope=(double) (x4 - x3)/ (0.5*(y3 - y2));
			double yc=(y2+y3)/2;
			for (int ys=y2; ys <= y3; ys++) {
				for (int xs=x3; xs <= x4; xs++) {
					if ( xs <= x4 + slope * (ys - yc) && xs <= x4 - slope * (ys - yc)) {
						values[xs][ys].flag=1;
						values[xs][ys].boundary = true;
					}
				}
			}

			for (int ys=y2; ys <= y3; ys++) {
				for (int xs=x1; xs <= x2; xs++) {
					if ( xs >= x1 + slope * (ys - yc) && xs >= x1 - slope * (ys - yc)) {
						values[xs][ys].flag=1;
						values[xs][ys].boundary = true;
					}
				}
			}
		}
		break;
	}
	case random_shape: {
		srand(time(0));
		int rand_shape = rand() % 9;
		Shape new_shape;
		switch (rand_shape) {
		case 0:
			new_shape = circle;
			break;
		case 1:
			new_shape = semicircle_north;
			break;
		case 2:
			new_shape = semicircle_south;
			break;
		case 3:
			new_shape = semicircle_west;
			break;
		case 4:
			new_shape = semicircle_east;
			break;
		case 5:
			new_shape = rectangle;
			break;
		case 6:
			new_shape = triangle;
			break;
		case 7:
			new_shape = ellipse;
			break;
		case 8:
			new_shape = star;
			break;
		}
		int x1 = 1 + rand()%(values.size() - 3);
		int x2 = 1 + rand()%(values.size() - 3);
		int x3 = 1 + rand()%(values.size() - 3);
		int x4 = 1 + rand()%(values.size() - 3);
		int x5 = (1 + rand()%(values.size() - 3) + 1 + rand()%(values[0].size() - 3)) / 4;

		int y1 = 1 + rand()%(values[0].size() - 3);
		int y2 = 1 + rand()%(values[0].size() - 3);
		int y3 = 1 + rand()%(values[0].size() - 3);
		int y4 = 1 + rand()%(values[0].size() - 3);
		int y5 = (1 + rand()%(values.size() - 3) + 1 + rand()%(values[0].size() - 3)) / 4;

		set_boundary_shape(x1,y1,x5,y5,new_shape,x2,x3,x4,y2,y3,y4);
	}
	} ///end of switch
}

double Grid::get_average_value(matrix &grid) {
	double sum = 0.;
	int entries = 0;
	for(int x = 1; x < grid.size() - 1; x++) {
		for(int y = 1; y < grid[0].size() - 1; y++) {
			if(grid[x][y].boundary == true && grid[x][y].flag == 1) {sum += grid[x][y].value;
			grid[x][y].flag = 0; entries++;}
		}
	}
	return (double) sum/entries;
}

void Grid::set_conductor(int x, int y, int dx, int dy, Shape shape) {
	set_conductor(x,y,dx,dy,shape,0,0,0,0,0,0);}

void Grid::set_conductor(int x, int y, int dx, int dy, Shape shape, int x1, int x2, int x3, int y1, int y2, int y3) {
	set_boundary_shape(x,y,dx,dy,shape, x1, x2, x3, y1, y2, y3);
	double val = get_average_value(values);
	set_boundary_shape(x,y,dx,dy,val,shape, x1, x2, x3, y1, y2, y3);
}


//Print ASCII table with MINIMAL formatting

void Grid::print_values() {
	cout << fixed;
	cout << endl;
	for (int y = 0; y <= values[0].size() - 1; y++) {
		cout << "[	";
		for (int x = 0; x < values.size(); x++) {
			cout << setprecision(2) << values[x][y].value << "	";
		}
		cout << "	]" << endl;
	}
	cout << endl;
}

//Print table with gnuplot matrix formatting. Plot in gnuplot by saving this to
//a file (let's call it data.dat) and calling in gnuplot:

//	plot 'data.dat' matrix with image

void Grid::print_gnuplot_values() {
	cout << fixed;
	for (int y = 0; y <= values[0].size() - 1; y++) {
		for (int x = 0; x < values.size(); x++) {
			cout << setprecision(2) << values[x][y].value << "	";
		}
		cout << endl;
	}
}

//prints to file sprecified in finite_difference.cc - lets us plot vector field
void Grid::print_all_to(string filename) {
	ofstream outdata;
	outdata.open(filename.c_str());
	if (outdata.is_open()) {
		for (int x = 0; x < values.size(); x++) {
			for (int y = 0; y < values[0].size(); y++) {

				outdata << x << "\t" << y << "\t" << values[x][y].value
						<<  endl;
			}
		}
		outdata.close();

	}

	else
		cout << "unable to open file" << endl;

}

void Grid::print_matrix_to(string filename) {
	ofstream outdata;
	outdata.open(filename.c_str());
	if (outdata.is_open()) {
		for (int y = 0; y < values.size(); y++) {
			for (int x = 0; x < values[0].size(); x++) {

				outdata << values[x][y].value << "\t";
			}
			outdata << "\n";
		}
		outdata.close();
	}

	else
		cout << "unable to open file" << endl;

}

void Grid::print_points() {
	cout << fixed;
	cout << endl;
	for (int y = 0; y <= points[0].size() - 1; y++) {
		cout << "[	";
		for (int x = 0; x < points.size(); x++) {
			cout << setprecision(0) << points[x][y].get_x() << ","
					<< points[x][y].get_y() << "	";
		}
		cout << "	]" << endl;
	}
	cout << endl;
}

// prints out the points for eq.p lines. n - the number of eq.pot. lines

void Grid::print_contours_to(string filename, int n) {
	ofstream outdata;
	outdata.open(filename.c_str());
	if (outdata.is_open()) {
		for (int i=1; i <= n; ++i) {
			outdata << "# Contour " << i-1 << ", label: \t " << i << endl;	
			for (int y = 0; y < values[0].size(); y++) {
				for (int x = 0; x < values.size(); x++) {
				
					if ( values[x][y].flag == i ) {
						if (x==0 || x==values.size()-1 || y==0 || y == values[0].size()-1 ) {outdata << x << "\t" << y << "\t"  << endl;}
						else if (values[x][y].flag != values[x][y+1].flag) {outdata << x << "\t" << y << "\t"  << endl;}
					}
				}
			}
			outdata << endl;
		}
		outdata.close();

	}

	else
		cout << "unable to open file" << endl;

}

// prints out the outline points (contour) of the figure. must specify the number of seperate figures ( usually just 1 )

void Grid::print_figure_to(string filename, int number_of_figures) {
	get_surface_points_of_figure();	
	ofstream outdata;
	outdata.open(filename.c_str());
	if (outdata.is_open()) 
		{
		for (int iii=0; iii < number_of_figures; ++iii)
			{
			outdata << "# Contour " << iii << ", label: \t " << "figure No " << iii+1 << endl;
			bool finished=0;			
			for (int y = 1; y < values[0].size()-1 && !finished; y++) 
				{	
				for (int x = 1; x < values.size()-1 && !finished; x++) 
					{
					if ( values[x][y].flag == 10000000 ) 
						{
						int xss = x;
						int yss = y;
						int x_prev=0;
						int y_prev=0;
						values[xss][yss].flag = 20000001;
						for (;;) 
							{
							if ( values[xss-1][yss].flag == 10000000 ) {  x_prev=xss; y_prev=yss; values[xss-1][yss].flag = 20000000; outdata << xss << "\t" << yss << endl; xss=xss-1;} 
							else if ( values[xss-1][yss+1].flag == 10000000 ) { x_prev=xss; y_prev=yss; values[xss-1][yss+1].flag = 20000000; outdata << xss << "\t" << yss << endl; xss=xss-1; yss=yss+1; }
							else if ( values[xss][yss+1].flag == 10000000 ) { x_prev=xss; y_prev=yss; values[xss][yss+1].flag = 20000000; outdata << xss << "\t" << yss <<  endl; yss=yss+1;}
							else if ( values[xss+1][yss+1].flag == 10000000 ) { x_prev=xss; y_prev=yss; values[xss+1][yss+1].flag = 20000000; outdata << xss << "\t" << yss << endl; xss=xss+1; yss=yss+1;} 
							else if ( values[xss+1][yss].flag == 10000000 ) { x_prev=xss; y_prev=yss; values[xss+1][yss].flag = 20000000; outdata << xss << "\t" << yss << endl; xss=xss+1;} 
							else if ( values[xss+1][yss-1].flag == 10000000 ) { x_prev=xss; y_prev=yss; values[xss+1][yss-1].flag = 20000000; outdata << xss << "\t" << yss << endl; xss=xss+1; yss=yss-1;} 
							else if ( values[xss][yss-1].flag == 10000000 ) { x_prev=xss; y_prev=yss; values[xss][yss-1].flag = 20000000; outdata << xss << "\t" << yss << endl; yss=yss-1;} 
							else if ( values[xss-1][yss-1].flag == 10000000 ) { x_prev=xss; y_prev=yss; values[xss-1][yss-1].flag = 20000000; outdata << xss << "\t" << yss <<  endl; xss=xss-1; yss=yss-1;} 
							else 
								{
								outdata << xss << "\t" << yss << endl;
								if (values[xss-1][yss].flag==20000001 || values[xss-1][yss+1].flag==20000001 || values[xss][yss+1].flag==20000001 || values[xss+1][yss+1].flag==20000001 || values[xss+1][yss].flag==20000001 || values[xss+1][yss-1].flag==20000001 || values[xss][yss-1].flag==20000001 || values[xss-1][yss-1].flag==20000001) 
									{
									
									outdata << x << "\t" << y << endl;
									finished =1;
									break;
									}
								else { xss=x_prev; yss=y_prev; }
								}
							}
						}
					}
				}		
			outdata << endl;
			}
		outdata.close();
		}

	else
		cout << "unable to open file" << endl;

}

// prints out the values of points in format:	 x	y	E

void Grid::print_points_to(string filename) {
	ofstream outdata;
	outdata.open(filename.c_str());
	if (outdata.is_open()) {
		for (int x = 0; x < values.size(); x++) {
			for (int y = 0; y < values[0].size(); y++) {
				outdata << x << "\t" << y << "\t" << values[x][y].value << endl;
			}
		}
		outdata.close();

	}

	else
		cout << "unable to open file" << endl;

}
void Grid::print_efield_to(string filename, int n) {
	ofstream outdata;
	outdata.open(filename.c_str());
	if (outdata.is_open()) {
		for (int i=1; i <= n; ++i) {
			outdata << "# Contour " << i-1 << ", label: \t " << i << endl;	
			for (int x = 1; x < values.size()-1; x++) {			
				for (int y = 1; y < values[0].size()-1; y++) {
				
					if ( values[x][y].flag == i ) {
						if (x==1 || x==values.size()-2 || y==1 || y == values[0].size()-2 ) {outdata << x << "\t" << y << "\t"  << endl;}
						else {outdata << x << "\t" << y << "\t"  << endl;}
					}
				}
			}
			outdata << endl;
		}
		outdata.close();

	}

	else
		cout << "unable to open file" << endl;

}
