\documentclass[aps,twocolumn,pre,nofootinbib,10pt]{revtex4-1}

%\usepackage{auto-pst-pdf}
\usepackage{algcompatible}
\usepackage[noend]{algpseudocode}
\usepackage{graphicx}
\graphicspath{{../../}}
\usepackage{amsmath,amssymb,amsfonts,amsthm}
\usepackage{bbm}
\usepackage{newfloat}

\DeclareFloatingEnvironment[
    fileext=loa,
    listname=List of Algorithms,
    name=ALGORITHM,
    placement=tbhp,
]{algorithm}
\newcommand*\Let[2]{\State #1 $\gets$ #2}

\begin{document}
\section{Algorithm Cost}
\subsection{Theoretical Analysis}

To calculate worst-case performance we can go through the algorithm and count operations, using a recurrence relation to obtain the total number of operations that will be perfrmed over the lifetime of the object.

While we aren't guaranteed great degrees of accuracy from this approach, we can at least know at which rate the time taken will increase by reducing the recurrence relation to 'big O' notation.

\subsubsection{Finite Difference}
\begin{algorithm}
    \caption{Finite Difference}
    \label{alg:fd}
    \begin{algorithmic}[1]
        \Function{iteration}{old}
            \Let{mo}{old}
            \Let{newm}{old}
            \Let{n}{widthOf(old)}
            \Let{m}{heightOf(old)}
            \Let{change}{0}
            \For{$x \gets 0 \textrm{ to } n$}
                \For{$y \gets 0 \textrm{ to } m$}
                    \If{$mo_{x,y} \textrm{ not a boundary }$}
                        \Let{$newm_{x,y}$}{$[{mo_{x-1,y}+mo_{x+1,y}+mo_{x,y-1}+mo_{x,y+1}}] / {2}$}
                    \EndIf
                    \If{$|newm_{x,y}-mo_{x,y}| > change$}
                        \Let{$change$}{$|newm_{x,y}-mo_{x,y}|$}
                    \EndIf
                \EndFor
            \EndFor
            \Let{next}{newm}
            \Let{next.error}{change}
            \State \Return{next}
        \EndFunction
        \Function{solve}{}
            \Let{first}{grid values}
            \Let{err}{1000}
            \Let{k}{1}
            \While{Not at desired precision AND not at maximum iterations}
                \Let{n}{$iteration(o)$}
                \Let{err}{$error(n)$}
                \Let{o}{n}
                \Let{iterations}{iterations + 1}
            \EndWhile
            \Let{solution}{n}
            \State \Return{solution}
        \EndFunction
    \end{algorithmic}
\end{algorithm}

There are 4 constant operations, 9 operations dependant on the number of iterations set (MAX) and 11 operations dependant on the size of the grid and the number of iterations set. This gives us \[L(11N+9)+4\] With L being the number of iterations set and N being the grid size.

We can reduce this to big O notation as O(n), giving us linear complexity.

\subsubsection{Fast Finite Difference}

The Fast Finite Difference method is an attempt to optimise the Finite Difference method. It is functionally the same, and arrives at the same approximation as the Finite Difference method will, however it takes much less time to do so.

\begin{algorithm}
    \caption{Fast Finite Difference}
    \label{alg:ffd}
    \begin{algorithmic}[1]
        \Function{solve}{}
            \Let{one}{grid values}
            \Let{two}{grid values}
            \Let{*current}{\&one}
            \Let{*alternate}{\&two}
            \Let{n}{widthOf(current)-1}
            \Let{n}{heightOf(current)-1}
            \For{$i \gets 0 \textrm{ to MAX, and not error}$}
                \Let{error}{1}
                \Let{temp}{current}
                \Let{current}{alternate}
                \Let{alternate}{temp}
                \For{$x \gets 1 \textrm{ to } n$}
                    \For{$y \gets 1 \textrm{ to } m$}
                        \If{$current_{x,y} \textrm{ not a boundary }$}
                            \Let{$alternate_{x,y}$}{$[{current_{x-1,y}+current_{x+1,y}+current_{x,y-1}+current_{x,y+1}}] / {2}$}
                            \If{$error \neq true$}
                                \Let{error}{$|alternate_{x,y} - current_{x,y}| > precision$}
                            \EndIf
                        \EndIf
                    \EndFor
                \EndFor
            \EndFor
        \EndFunction
    \end{algorithmic}
\end{algorithm}

There are 7 constant operations, 6 operations dependant on the maximum number of iterations set (MAX) and 6 operations dependant on the number of grid elements and the maximum number of iterations. This gives us a complexity of \[L(6n + 6) + 7\], where L is the number of iterations and n is the grid size. We can reduce this to Big O notation as O(n), giving us an algorithm with linear complexity.

\subsubsection{Asymmetric Finite Volume}

\begin{algorithm}
    \caption{Asymmetric Finite Volume}
    \label{alg:afv}
    \begin{algorithmic}
        \Function{iteration}{old}
        \Let{m}{old.it}
        \Let{no}{height(m)}
        \Let{mo}{width(m)}
        \Let{change}{0}
        \State cells
        \State dv
        \State old\_value
        \State DV
        \State coefficient
        \State total\_difference
        \State count
        \For{$x \gets 1 \textrm{ to } no-1$}
            \For{$y \gets 1 \textrm{ to } mo-1$}
                \Let{old\_value}{$m_{x,y}$}
                \If{$m_{x-1,y}$ is accessible}
                    \Let{cells}{$m_{x-1,y}$}
                    \Let{dv}{$m_{x,y} - m_{x-1,y}$}
                \EndIf
                \If{$m_{x+1,y}$ is accessible}
                    \Let{cells}{$m_{x+1,y}$}
                    \Let{dv}{$m_{x,y} - m_{x+1,y}$}
                \EndIf
                \If{$m_{x,y-1}$ is accessible}
                    \Let{cells}{$m_{x-1,y}$}
                    \Let{dv}{$m_{x,y} - m_{x,y-1}$}
                \EndIf
                \If{$m_{x,y+1}$ is accessible}
                    \Let{cells}{$m_{x,y+1}$}
                    \Let{dv}{$m_{x,y} - m_{x,y+1}$}
                \EndIf
                \Let{cells}{$m_{x,y}$}
                \Let{average}{average(cells)}
                \If{$m_{x,y}$ not boundary}
                    \Let{$m_{x,y}$}{average}
                    \Let{DV}{average-old\_value}
                    \If{$|DV| > \textrm{ change }$}
                        \Let{change}{$|DV|$}
                    \EndIf
                    \Let{total\_Difference}{total\_value(dv)}
                    \If{total difference = 0 or DV = 0}
                        \If{$m_{x-1,y} and m_{x+1,y} \textrm{ are accessible }$}
                            \Let{xnew}{[$m_{x-1,y}+m_{x+1,y}]/2$}
                            \If{$m_{x-1,y} \textrm{ not boundary }$}
                                \Let{$m_{x-1,y}$}{xnew}
                            \EndIf
                            \If{$m_{x+1,y} \textrm{ not boundary }$}
                                \Let{$m_{x+1,y}$}{xnew}
                            \EndIf
                        \EndIf
                        \If{$m_{x,y-1} and m_{x,y+1} \textrm{ are accessible }$}
                            \Let{ynew}{[$m_{x,y-1}+m_{x,y+1}]/2$}
                            \If{$m_{x,y-1} \textrm{ not boundary }$}
                                \Let{$m_{x,y-1}$}{ynew}
                            \EndIf
                            \If{$m_{x,y+1} \textrm{ not boundary }$}
                                \Let{$m_{x,y+1}$}{ynew}
                            \EndIf
                        \EndIf
                    \EndIf
                    \Else
                        \Let{coefficient}{$-DV/total_difference$}
                        \Let{count}{0}
                        \If{$m_{x-1,y} \textrm{ is accessible}$}
                            \If{$m_{x-1,y} \textrm{ not boundary }$}
                                \Let{$m_{x-1,y}$}{$m_{x-1,y} = m_{x-1,y} + \textrm{ coefficient } * dv_{count}$}
                                \Let{count}{count + 1}
                            \EndIf
                        \EndIf
                        \If{$m_{x+1,y} \textrm{ is accessible}$}
                            \If{$m_{x+1,y} \textrm{ not boundary }$}
                                \Let{$m_{x+1,y}$}{$m_{x+1,y} = m_{x+1,y} + \textrm{ coefficient } * dv_{count}$}
                                \Let{count}{count + 1}
                            \EndIf
                        \EndIf
                        \If{$m_{x,y-1} \textrm{ is accessible}$}
                            \If{$m_{x,y-1} \textrm{ not boundary }$}
                                \Let{$m_{x-1,y}$}{$m_{x,y-1} = m_{x,y-1} + \textrm{ coefficient } * dv_{count}$}
                                \Let{count}{count + 1}
                            \EndIf
                        \EndIf
                        \If{$m_{x,y+1} \textrm{ is accessible}$}
                            \If{$m_{x,y+1} \textrm{ not boundary }$}
                                \Let{$m_{x,y+1}$}{$m_{x,y+1} = m_{x,y+1} + \textrm{ coefficient } * dv_{count}$}
                                \Let{count}{count + 1}
                            \EndIf
                        \EndIf
                    \State clear cells
                    \State clear dv
                \EndIf
            \EndFor
        \EndFor
        \EndFunction
    \end{algorithmic}
\end{algorithm}

There are 11 constant operations, 19 operations dependant on the maximum number of iterations set (MAX) and 34 operations dependant on the number of grid elements and the maximum number of iterations. This gives us a complexity of \[L(34N+19)+11\], where L is the number of iterations and N is the grid size. We can reduce this to Big O notation as O(n), giving us an algorithm with linear complexity.

\subsection{Experimental Analysis}
\subsubsection{Worst Case}

To obtain an idea of the worst-case performance of each algorithm at a certain grid size we can run all of the algorithms for a set number of iterations so that we can obtain a relation between the grid size and the upper bound on run time.

The experimental set up for this involved creating three identical Grids, with a flow of -50 to 50; a circular conductor set at the mid point of the grid with a radius of a tenth of the height of the grid.

We then run each of the algorithms on their respective grids recording the time taken for the run, and increasing the grid size for each run.

\begin{figure}
    \begin{center}
        \includegraphics*[angle=-90,width = \columnwidth ]{comparison_wc.ps}
    \end{center}
\end{figure}

We get a gradient of $5.11*10^{-3}$ for afv, $2.11*10^{-4}$ for fd, and $3.66*10{-5}$ for ffd.

Using this we can calculate how long each algorithm would take to run a certain grid size, for example for a grid size of 1000 by 1000 the Fast Finite Difference method would take 36.6 seconds; Finite Difference would take 211 seconds; and Asymmetric Finite Volume would take 5110 seconds on the experimenters system.

\subsubsection{Average Case}

To obtain the average case performance of the algorithms, we shall run each of the algorithms as previously, but setting the precision to some non-zero value. This will allow the algorithms to finish after they have reached this precision and will give us an idea of the average case performance of the algorithms.

\begin{figure}
    \begin{center}
        \includegraphics*[angle=-90,width=\columnwidth]{comparison_ac.ps}
    \end{center}
\end{figure}

After running this we can see that the gradient of the afv method is $5.16*10^{-3}$, fd is $2.21*10^{-4}$ and ffd is $3.30*10^{-5}$

\subsection{Comparison of the methods}
%TODO Write a comparison of the algorithms and in particular talk about the changes in the ffd which allows to be so much quicker than fd

\end{document}

