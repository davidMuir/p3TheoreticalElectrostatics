#include "../Structures/Grid.h"
#include "../Structures/Coordinate.h"

class Analytic {
 public:
  Analytic(Grid entry){
    grid = entry;

  }
  ~Analytic(){};

  void solve(int x, int y, unsigned int r, double val, double h){ 
    matrix sol = grid.get_values();
if(x<r || x+r>sol.size()-1 || y<r || y+r>sol[0].size()-1)
      cout << "Out of range" << endl;
 double e_lim = sol[0][sol.size()/2].value*h/x;

    for(int xs=0; xs<sol.size(); xs++){
      for(int ys=0; ys<sol[0].size();ys++){
	Coordinate xy;
	xy.set_xy(xs/h,ys/h);
	Coordinate mid;
	mid.set_xy(x/h,y/h);
	if(mid.distance(xy) < r/h){
	  sol[xs][ys].value = val;
	}
	else{
	  double dist = mid.distance(xy);
	  sol[xs][ys].value = val + e_lim*(xy.get_x()-mid.get_x())/dist*(r*r/(h*h*dist) - dist);
	}
      }
    }
    solution.set_values(sol);
    solution.set_coordinates(grid.get_coordinates());
    solution.set_gradients(grid.get_gradients());
  }

  Grid get_solution(){
    return solution;
  }


  Grid find_err(Grid numer_grid){
    matrix num = numer_grid.get_values();
    matrix an = solution.get_values();
    err_grid.set_values(solution.get_values()); //Done to set ratio_grid to right size - the values will be changed.
    if(an.size()!= num.size() || an[0].size() != num[0].size()){
      cout << "Error: grids not the same size" << endl;
    }else{
      for(int xs=0; xs<num.size(); xs++){
	for(int ys=0; ys<num[0].size(); ys++){
	  double num_val =num[xs][ys].value;
	  double an_val = an[xs][ys].value;
	  err_grid.set_value(xs,ys,num_val-an_val);
	}
      }
       
      err_grid.set_coordinates(solution.get_coordinates());
      err_grid.set_gradients(solution.get_gradients());
      return err_grid;
    }
  }

 private:
 Grid solution;
 Grid grid;
 Grid err_grid;
 Grid num_grid;


};
