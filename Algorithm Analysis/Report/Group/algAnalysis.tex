<<<<<<< HEAD
\documentclass[aps,twocolumn,pre,nofootinbib,10pt]{revtex4-1}

%\usepackage{auto-pst-pdf}
\usepackage{algcompatible}
\usepackage[noend]{algpseudocode}
\usepackage{graphicx}
\graphicspath{{../../}}
\usepackage{amsmath,amssymb,amsfonts,amsthm}
\usepackage{bbm}
\usepackage{newfloat}

\DeclareFloatingEnvironment[
    fileext=loa,
    listname=List of Algorithms,
    name=ALGORITHM,
    placement=tbhp,
]{algorithm}
=======
\documentclass{article}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage[dvips]{graphicx}
\graphicspath{{../../}}
>>>>>>> 69c07bc55d7839c56601ca061c8f92843e5b0883
\newcommand*\Let[2]{\State #1 $\gets$ #2}

\begin{document}
\section{Algorithm Cost}
\subsection{Theoretical Analysis}

To calculate worst-case performance we can go through the algorithm and count operations, using a recurrence relation to obtain the total number of operations that will be perfrmed over the lifetime of the object.

While we aren't guaranteed great degrees of accuracy from this approach, we can at least know at which rate the time taken will increase by reducing the recurrence relation to 'big O' notation.

\subsubsection{Finite Difference}
\begin{algorithm}
    \caption{Finite Difference}
    \label{alg:fd}
    \begin{algorithmic}[1]
        \Function{iteration}{old}
            \Let{mo}{old}
            \Let{newm}{old}
            \Let{n}{widthOf(old)}
            \Let{m}{heightOf(old)}
            \Let{change}{0}
            \For{$x \gets 0 \textrm{ to } n$}
                \For{$y \gets 0 \textrm{ to } m$}
                    \If{$mo_{x,y} \textrm{ not a boundary }$}
                        \Let{$newm_{x,y}$}{$[{mo_{x-1,y}+mo_{x+1,y}+mo_{x,y-1}+mo_{x,y+1}}] / {2}$}
                    \EndIf
                    \If{$|newm_{x,y}-mo_{x,y}| > change$}
                        \Let{$change$}{$|newm_{x,y}-mo_{x,y}|$}
                    \EndIf
                \EndFor
            \EndFor
            \Let{next}{newm}
            \Let{next.error}{change}
            \State \Return{next}
        \EndFunction
        \Function{solve}{}
            \Let{first}{grid values}
            \Let{err}{1000}
            \Let{k}{1}
            \While{Not at desired precision AND not at maximum iterations}
                \Let{n}{$iteration(o)$}
                \Let{err}{$error(n)$}
                \Let{o}{n}
                \Let{iterations}{iterations + 1}
            \EndWhile
            \Let{solution}{n}
            \State \Return{solution}
        \EndFunction
    \end{algorithmic}
\end{algorithm}

<<<<<<< HEAD
There are 4 constant operations, 9 operations dependant on the number of iterations set (MAX) and 11 operations dependant on the size of the grid and the number of iterations set. This gives us \[L(11N+9)+4\] With L being the number of iterations set and N being the grid size.

We can reduce this to big O notation as O(n), giving us linear complexity.

\subsubsection{Fast Finite Difference}

The Fast Finite Difference method is an attempt to optimise the Finite Difference method. It is functionally the same, and arrives at the same approximation as the Finite Difference method will, however it takes much less time to do so.

=======
We get \[L(11N+9)+4\] by counting operations and can reduce this to O(n) in big O notation.

\subsubsection{Fast Finite Difference}
>>>>>>> 69c07bc55d7839c56601ca061c8f92843e5b0883
\begin{algorithm}
    \caption{Fast Finite Difference}
    \label{alg:ffd}
    \begin{algorithmic}[1]
        \Function{solve}{}
            \Let{one}{grid values}
            \Let{two}{grid values}
            \Let{*current}{\&one}
            \Let{*alternate}{\&two}
            \Let{n}{widthOf(current)-1}
            \Let{n}{heightOf(current)-1}
            \For{$i \gets 0 \textrm{ to MAX, and not error}$}
                \Let{error}{1}
                \Let{temp}{current}
                \Let{current}{alternate}
                \Let{alternate}{temp}
                \For{$x \gets 1 \textrm{ to } n$}
                    \For{$y \gets 1 \textrm{ to } m$}
                        \If{$current_{x,y} \textrm{ not a boundary }$}
                            \Let{$alternate_{x,y}$}{$[{current_{x-1,y}+current_{x+1,y}+current_{x,y-1}+current_{x,y+1}}] / {2}$}
                            \If{$error \neq true$}
                                \Let{error}{$|alternate_{x,y} - current_{x,y}| > precision$}
                            \EndIf
                        \EndIf
                    \EndFor
                \EndFor
            \EndFor
        \EndFunction
    \end{algorithmic}
\end{algorithm}

There are 7 constant operations, 6 operations dependant on the maximum number of iterations set (MAX) and 6 operations dependant on the number of grid elements and the maximum number of iterations. This gives us a complexity of \[L(6n + 6) + 7\], where L is the number of iterations and n is the grid size. We can reduce this to Big O notation as O(n), giving us an algorithm with linear complexity.
<<<<<<< HEAD

\subsubsection{Asymmetric Finite Volume}

%\begin{algorithm}
%   \caption{Asymmetric Finite Volume}
%  \label{alg:afv}
%  \begin{algorithmic}
%     \Function{iteration}{old}
%     \Let{m}{old.it}
%      \Let{no}{height(m)}
%     \Let{mo}{width(m)}
%      \Let{change}{0}
%      \State cells
%      \State dv
%      \State old\_value
%      \State DV
%      \State coefficient
%      \State total\_difference
%      \State count
%      \For{$x \gets 1 \textrm{ to } no-1$}
%          \For{$y \gets 1 \textrm{ to } mo-1$}
%              \Let{old\_value}{$m_{x,y}$}
%              \If{$m_{x-1,y}$ is accessible}
%                  \Let{cells}{$m_{x-1,y}$}
%                  \Let{dv}{$m_{x,y} - m_{x-1,y}$}
%               \EndIf
%               \If{$m_{x+1,y}$ is accessible}
%                   \Let{cells}{$m_{x+1,y}$}
%                   \Let{dv}{$m_{x,y} - m_{x+1,y}$}
%               \EndIf
%               \If{$m_{x,y-1}$ is accessible}
%                   \Let{cells}{$m_{x-1,y}$}
%                   \Let{dv}{$m_{x,y} - m_{x,y-1}$}
%               \EndIf
%               \If{$m_{x,y+1}$ is accessible}
%                   \Let{cells}{$m_{x,y+1}$}
%                   \Let{dv}{$m_{x,y} - m_{x,y+1}$}
%               \EndIf
%               \Let{cells}{$m_{x,y}$}
%               \Let{average}{average(cells)}
%               \If{$m_{x,y}$ not boundary}
%                   \Let{$m_{x,y}$}{average}
%                   \Let{DV}{average-old\_value}
%                   \If{$|DV| > \textrm{ change }$}
%                       \Let{change}{$|DV|$}
%                   \EndIf
%                   \Let{total\_Difference}{total\_value(dv)}
%                   \If{total difference = 0 or DV = 0}
%                       \If{$m_{x-1,y} and m_{x+1,y} \textrm{ are accessible }$}
%                           \Let{xnew}{[$m_{x-1,y}+m_{x+1,y}]/2$}
%                           \If{$m_{x-1,y} \textrm{ not boundary }$}
%                               \Let{$m_{x-1,y}$}{xnew}
%                           \EndIf
%                           \If{$m_{x+1,y} \textrm{ not boundary }$}
%                               \Let{$m_{x+1,y}$}{xnew}
%                           \EndIf
%                       \EndIf
%                       \If{$m_{x,y-1} and m_{x,y+1} \textrm{ are accessible }$}
%                           \Let{ynew}{[$m_{x,y-1}+m_{x,y+1}]/2$}
%                           \If{$m_{x,y-1} \textrm{ not boundary }$}
%                               \Let{$m_{x,y-1}$}{ynew}
%                           \EndIf
%                           \If{$m_{x,y+1} \textrm{ not boundary }$}
%                               \Let{$m_{x,y+1}$}{ynew}
%                           \EndIf
%                       \EndIf
%                   \EndIf
%                   \Else
%                       \Let{coefficient}{$-DV/total_difference$}
%                       \Let{count}{0}
%                       \If{$m_{x-1,y} \textrm{ is accessible}$}
%                           \If{$m_{x-1,y} \textrm{ not boundary }$}
%                               \Let{$m_{x-1,y}$}{$m_{x-1,y} = m_{x-1,y} + \textrm{ coefficient } * dv_{count}$}
%                               \Let{count}{count + 1}
%                           \EndIf
%                       \EndIf
%                       \If{$m_{x+1,y} \textrm{ is accessible}$}
%                           \If{$m_{x+1,y} \textrm{ not boundary }$}
%                               \Let{$m_{x+1,y}$}{$m_{x+1,y} = m_{x+1,y} + \textrm{ coefficient } * dv_{count}$}
%                               \Let{count}{count + 1}
%                           \EndIf
%                       \EndIf
%                       \If{$m_{x,y-1} \textrm{ is accessible}$}
%                           \If{$m_{x,y-1} \textrm{ not boundary }$}
%                               \Let{$m_{x-1,y}$}{$m_{x,y-1} = m_{x,y-1} + \textrm{ coefficient } * dv_{count}$}
%                               \Let{count}{count + 1}
%                           \EndIf
%                       \EndIf
%                       \If{$m_{x,y+1} \textrm{ is accessible}$}
%                           \If{$m_{x,y+1} \textrm{ not boundary }$}
%                               \Let{$m_{x,y+1}$}{$m_{x,y+1} = m_{x,y+1} + \textrm{ coefficient } * dv_{count}$}
%                               \Let{count}{count + 1}
%                           \EndIf
%                       \EndIf
%                   \State clear cells
%                   \State clear dv
%               \EndIf
%           \EndFor
%       \EndFor
%       \EndFunction
%   \end{algorithmic}
%\end{algorithm}

Due to the scale of this method the pseudocode has not been included. 

There are 11 constant operations, 19 operations dependant on the maximum number of iterations set (MAX) and 34 operations dependant on the number of grid elements and the maximum number of iterations. This gives us a complexity of \[L(34N+19)+11\], where L is the number of iterations and N is the grid size. We can reduce this to Big O notation as O(n), giving us an algorithm with linear complexity.
=======
\subsubsection{Asymmetric Finite Volume}
Stick the pseudocode in here -- maybe not, might need to stick this in the appendix.
Count the number of operations

The operations count comes out as (approximately -- need to check) \[L(34N+19)+11\]
>>>>>>> 69c07bc55d7839c56601ca061c8f92843e5b0883

\subsection{Experimental Analysis}
\subsubsection{Worst Case}

To obtain an idea of the worst-case performance of each algorithm at a certain grid size we can run all of the algorithms for a set number of iterations so that we can obtain a relation between the grid size and the upper bound on run time.

The experimental set up for this involved creating three identical Grids, with a flow of -50 to 50; a circular conductor set at the mid point of the grid with a radius of a tenth of the height of the grid.

We then run each of the algorithms on their respective grids recording the time taken for the run, and increasing the grid size for each run.

<<<<<<< HEAD
\begin{figure}
    \begin{center}
        \includegraphics*[angle=-90,width = \columnwidth ]{comparison_wc.ps}
    \end{center}
\end{figure}

We get a gradient of $5.11*10^{-3}$ for afv, $2.11*10^{-4}$ for fd, and $3.66*10{-5}$ for ffd.

Using this we can calculate how long each algorithm would take to run a certain grid size, for example for a grid size of 1000 by 1000 the Fast Finite Difference method would take 36.6 seconds; Finite Difference would take 211 seconds; and Asymmetric Finite Volume would take 5110 seconds on the experimenters system.

\subsubsection{Average Case}

To obtain the average case performance of the algorithms, we shall run each of the algorithms as previously, but setting the precision to some non-zero value. This will allow the algorithms to finish after they have reached this precision and will give us an idea of the average case performance of the algorithms.

\begin{figure}
    \begin{center}
        \includegraphics*[angle=-90,width=\columnwidth]{comparison_ac.ps}
    \end{center}
\end{figure}

After running this we can see that the gradient of the afv method is $5.16*10^{-3}$, fd is $2.21*10^{-4}$ and ffd is $3.30*10^{-5}$

\subsection{Comparison of the methods}
%TODO Write a comparison of the algorithms and in particular talk about the changes in the ffd which allows to be so much quicker than fd

There is a clear trend between the number of operations performed per iteration and the relative performances of the algorithms. With the fastest algorithm, Fast Finite Difference having 6 operations per iteration; Fast Finite Difference having 11 operations per iteration and having a worst case performance of 5.77 times that of Fast Finite Difference; and Asymmetric Finite Volume having 34 operations per iteration and a relative performance of 139.62 compared to Fast
Finite Difference. 

\end{document}

=======
\begin{figure*}
    \begin{center}
        \includegraphics*[angle=-90,width = 0.9 \textwidth]{fd_ffd_comparison.ps}
    \end{center}
\end{figure*}
\begin{figure*}
    \begin{center}
        \includegraphics*[angle=-90,width = 0.9 \textwidth]{afv.ps}
    \end{center}
\end{figure*}

We get a gradient of $5.11*10^{-3}$ for afv, $2.11*10^{-4}$ for fd, and $3.66*10{-5}$ for ffd.

\subsubsection{Average Case}

Run the experiment with precision at some set value, to see if the rate at which they converge is relatively different between the algorithms.


\end{document}
>>>>>>> 69c07bc55d7839c56601ca061c8f92843e5b0883
