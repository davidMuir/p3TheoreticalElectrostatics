\documentclass{article}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage[dvips]{graphicx}
\graphicspath{{../../}}
\newcommand*\Let[2]{\State #1 $\gets$ #2}

\begin{document}
\section{Algorithm Cost}
\subsection{Theoretical Analysis}

To calculate worst-case performance we can go through the algorithm and count operations, using a recurrence relation to obtain the total number of operations that will be perfrmed over the lifetime of the object.

While we aren't guaranteed great degrees of accuracy from this approach, we can at least know at which rate the time taken will increase by reducing the recurrence relation to 'big O' notation.

\subsubsection{Finite Difference}
\begin{algorithm}
    \caption{Finite Difference}
    \label{alg:fd}
    \begin{algorithmic}[1]
        \Function{iteration}{old}
            \Let{mo}{old}
            \Let{newm}{old}
            \Let{n}{widthOf(old)}
            \Let{m}{heightOf(old)}
            \Let{change}{0}
            \For{$x \gets 0 \textrm{ to } n$}
                \For{$y \gets 0 \textrm{ to } m$}
                    \If{$mo_{x,y} \textrm{ not a boundary }$}
                        \Let{$newm_{x,y}$}{$[{mo_{x-1,y}+mo_{x+1,y}+mo_{x,y-1}+mo_{x,y+1}}] / {2}$}
                    \EndIf
                    \If{$|newm_{x,y}-mo_{x,y}| > change$}
                        \Let{$change$}{$|newm_{x,y}-mo_{x,y}|$}
                    \EndIf
                \EndFor
            \EndFor
            \Let{next}{newm}
            \Let{next.error}{change}
            \State \Return{next}
        \EndFunction
        \Function{solve}{}
            \Let{first}{grid values}
            \Let{err}{1000}
            \Let{k}{1}
            \While{Not at desired precision AND not at maximum iterations}
                \Let{n}{$iteration(o)$}
                \Let{err}{$error(n)$}
                \Let{o}{n}
                \Let{iterations}{iterations + 1}
            \EndWhile
            \Let{solution}{n}
            \State \Return{solution}
        \EndFunction
    \end{algorithmic}
\end{algorithm}

We get \[L(11N+9)+4\] by counting operations and can reduce this to O(n) in big O notation.

\subsubsection{Fast Finite Difference}
\begin{algorithm}
    \caption{Fast Finite Difference}
    \label{alg:ffd}
    \begin{algorithmic}[1]
        \Function{solve}{}
            \Let{one}{grid values}
            \Let{two}{grid values}
            \Let{*current}{\&one}
            \Let{*alternate}{\&two}
            \Let{n}{widthOf(current)-1}
            \Let{n}{heightOf(current)-1}
            \For{$i \gets 0 \textrm{ to MAX, and not error}$}
                \Let{error}{1}
                \Let{temp}{current}
                \Let{current}{alternate}
                \Let{alternate}{temp}
                \For{$x \gets 1 \textrm{ to } n$}
                    \For{$y \gets 1 \textrm{ to } m$}
                        \If{$current_{x,y} \textrm{ not a boundary }$}
                            \Let{$alternate_{x,y}$}{$[{current_{x-1,y}+current_{x+1,y}+current_{x,y-1}+current_{x,y+1}}] / {2}$}
                            \If{$error \neq true$}
                                \Let{error}{$|alternate_{x,y} - current_{x,y}| > precision$}
                            \EndIf
                        \EndIf
                    \EndFor
                \EndFor
            \EndFor
        \EndFunction
    \end{algorithmic}
\end{algorithm}

There are 7 constant operations, 6 operations dependant on the maximum number of iterations set (MAX) and 6 operations dependant on the number of grid elements and the maximum number of iterations. This gives us a complexity of \[L(6n + 6) + 7\], where L is the number of iterations and n is the grid size. We can reduce this to Big O notation as O(n), giving us an algorithm with linear complexity.
\subsubsection{Asymmetric Finite Volume}
Stick the pseudocode in here -- maybe not, might need to stick this in the appendix.
Count the number of operations

The operations count comes out as (approximately -- need to check) \[L(34N+19)+11\]

\subsection{Experimental Analysis}
\subsubsection{Worst Case}

To obtain an idea of the worst-case performance of each algorithm at a certain grid size we can run all of the algorithms for a set number of iterations so that we can obtain a relation between the grid size and the upper bound on run time.

The experimental set up for this involved creating three identical Grids, with a flow of -50 to 50; a circular conductor set at the mid point of the grid with a radius of a tenth of the height of the grid.

We then run each of the algorithms on their respective grids recording the time taken for the run, and increasing the grid size for each run.

\begin{figure*}
    \begin{center}
        \includegraphics*[angle=-90,width = 0.9 \textwidth]{fd_ffd_comparison.ps}
    \end{center}
\end{figure*}
\begin{figure*}
    \begin{center}
        \includegraphics*[angle=-90,width = 0.9 \textwidth]{afv.ps}
    \end{center}
\end{figure*}

We get a gradient of $5.11*10^{-3}$ for afv, $2.11*10^{-4}$ for fd, and $3.66*10{-5}$ for ffd.

\subsubsection{Average Case}

Run the experiment with precision at some set value, to see if the rate at which they converge is relatively different between the algorithms.


\end{document}
